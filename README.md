# GeoQuiz

“실무에 바로 적용하는 안드로이드 프로그래밍”

* 1일차

0. 구글스토어에 배포 : 안드로이드 도구들이 우리의 리소스와 코드, xml 파일들을 가지고 하나의 .apk로 만들어 주는데 구글에서 릴리즈 키를 받아 앱에 포함시켜야 배포가 가능

1. GeoQuiz 앱 시작

(1) 첫앱
- 리니어 레이아웃 (루트) 아래에 하나의 TextView와 하나의 리니어 레이아웃, 리니어 레이아웃 아래에 두개의 버튼뷰

- match_parent은 부모노드의 크기에 꽉 채우는 것
- wrap_content는 각 뷰의 크기를 가지는 것 (ex padding=24dp)

- 인플레이트 (레이아웃을 뷰 객체로 생성하는 것)

- strings.xml 파일안에 우리가 사용할 문자열들을 저장해놓고 참조해서 가져다 쓰게함 -> 여기에 지정하지 않고 그냥 코드에 텍스트로 때려넣을경우 호환성이나 다른 국가 언어 호환이 어려움

- 레이아웃은 하나의 레이아웃 전체에 대해 하나의 리소스 id가 생성되는데 
- 개별적인 위젯들에 대한 리소스 id는 생성되어 있지않다
- 코드에서 참조하여 사용할 필요가 있는 위젯만 리소스 id를 지정하면됨
- “android:id=“@+id/true_button” 이런식으로 xml에 추가
- 이제 자바파일에서 리소스 id를 통해 이 버튼들을 사용가능
- “android:text=“@string/false_button” text 속성에서는 문자열을 참조만 하는 것이기 때문에 +가 빠짐

- 위젯을 코드와 연결 (뷰 객체들에 대한 참조를 얻고, 사용자의 액션에 응답하기 위해 그 객체들에 대한 리스너를 설정)
- 위젯의 참조 얻기 View findViewById(int id) 라는 액티비티 메소드를 호출
- 안드로이드 앱은 이벤트 기반으로 구동 (사용자의 이벤트 발생을 기다림)
- 즉 앱에서 특정 이벤트를 기다리는 것을 가르켜 리스닝 이라고 함
- 그 이벤트에 응답하기 위해 리스너 인터페이스를 구현하는 리스너 를 생성함
- 여기서는 버튼이 눌러졌는가가 이벤트이므로 View.OnClickListner 인터페이스를 구현해야함


(2) 안드로이드와 모델-뷰-컨트롤러
- 객체들은 모델, 컨트롤러, 뷰로 분리됨
- 안드로이드 앱은 모델-뷰-컨트롤러 (줄여서 MVC)라는 아키텍쳐에 맞추어 설계됨
- 애플리케이션의 어떤 객체든 모델 객체 또는 뷰 객체 또는 컨트롤러 객체가 되어야한다는 것이 MVC의 주요관점
- 모델 객체 : 앱의 데이터와 비즈니스 로직을 가짐, 데이터를 보존하고 관리하는 것
- 뷰 객체 : 화면에 그리는 방법, 터치와 같은 사용자의 입력에 응답하는 방법을 앎. 즉 화면에서 볼 수 있는 것이라면 뷰 객체임
- 컨트롤러 객체 : 뷰와 모델 객체를 결속시키고 어플리케이션 로직을 포함함 => 일반적으로 Activity, Fragment, Service의 서브 클래스임

- MVC의 장점 : 심플하고 재사용성이 쉽고, 관심의 분리

- 리소스에 drawable은 화면에 그릴수 있는 리소스의 참조할때 쓰인다 (@drawable/로 시작)


(3) 액티비티 생명주기
- 액티비티의 모든 인스턴스는 생명주기를 갖고 생명주기 동안에 액티비티는 세가지 상태 (실행, 일시중지, 중단)으로 상호 전환된다
- 이 전환이 발생할때 액티비티에 상태 변경을 알려주는 액티비티 메서드들이 있음 (안드로이드 런타임이 자동 호출함)

- 액티비티 생명주기 로깅
- android.util.Log 클래스는 공유되는 시스템 로그로 로그 메세지를 전달함
- Log 클래스는 로그 메시지를 처리하기 의한 메소드들을 가지고 있는데 그중 d 라는 메소드를 자주 사용하여 로그 메시지를 기록함 

- 장치회전과 대체 리소스 : 리소스의 layout에 가로 방향의 layout을 따로 추가한다.
- 장치를 회전할때 안드로이드는 현재의 QuizActivity 인스턴스를 소멸시키고 새로 생성하여 시작시킴

- 장치회전 시 데이터 저장 : 장치 회전시에 액티비티를 소멸시키고 재생성하면 첫질문부터 다시 시작하게되는 문제 발생
- 이걸 해결하려면 새로 생성된 인스턴스에서 mCurrentIndex 값을 저장해야하는데 
- onPause(), onStop(), onDestroy()가 호출되기 전에 onSaveInstanceState 액티비티 메서드를 오버라이드 하여 호출하면됨
- 즉 bundle이라는 객체에 전 정보를 저장하고 (bundle은 키와 값 한 쌍으로 데이터를 저장하는 구조)
- 그 bundle 객체는 안드로이드 운영체제에 의해 우리 액티비티의 액티비티 레코드로 수록됨
- Bundle savedInstanceState에 키와 값으로 저장하고 인스턴스 재생성시 이 bundle에서 가져와 설정
- 약티비티 레코드는 사용자가 “back”을 누르거나 재부팅하거나 오랫동안 사용되지 않을때만 폐기됨
- 즉 액티비티가 죽거나 어플 프로세스가 완전히 셧다운 될때는 액티비티 레코드가 살아 있으므로 신속하게 재실행 가능


* 전체적인 복습
- MVC (모델-뷰-컨트롤러) 아키텍쳐에 맞게 구현
- 모델은 우리가 필요한 데이터나 클래스등을 정의하는 것들이고
- 뷰는 안드로이드에서 제공하는 객체들 (버튼, 이미지버튼, 이벤트 등)
- 컨트롤러는 드라이버같은 개념으로 모델과 뷰를 연결시켜 핸들링하는 역할 (액티비티, 프래그먼트 등)
- 앱을 만들때 먼저 원하는 뷰 객체들을 UI 상에서 위치를 고려하여 레이아웃, 위젯들로 구성하고 이것을 xml내에 추가 시킨다
- 이 xml 안에 여러 속성들을 변경할 수 있고 원하는 용도, 위치에 맞게 조절 가능하고
- 참조가 필요한 위젯이라면 리소스 id를 추가하여 컨트롤러 부분에서 참조 할 수 있도록 만든다
- 데이터를 저장하기에 효울적인 클래스를 구현하고
- 컨트롤러 부분에서 각 뷰 객체들과 모델 객체들을 참조해와 실질적인 코딩을 작업을 한다
- 여기서 객체들을 참조할 때는 간단한 스트링일지라도 리소스 내의 strings.xml에 추가하는 등 캡슐화를 생각하면서 구현한다



* 2일차

(4) 안드로이드 앱의 디버깅
- LogCat, 안드로이드 Lint 및 안드로이드 스튜디오에 포함된 디버거 사용법
- LogCat의 “Caused by” 에러 부분을 확인하여 코드 라인 확인
- Log.d 를 활용해 스택 로깅으로 결함 코드를 찾아낸다
- Break point 이용해서 디버깅 도구 활용

- 안드로이드 특유의 문제점들을 확인하기 위한 디버깅. --> Lint
- Lint는 안드로이드 코드의 정적 분석기임 (정적 분석기란 앱을 실행하지 않고 코드를 조사하여 결함을 찾는것)
- “Analyze -> Inspect code”를 이용


(5) 두번째 액티비티 만들기
- 새로운 빈 액티비티를 생성 (Launcher Activity 항목은 앱이 실행될때 최초로 실행되는 액티비티를 의미)
- 처음 만든 액티비티는 이미 매니페스트에 자동으로 선언되어있고 두번째 액티비티부터도 매니페스트에 자동추가됨

- Void startActivitt(Intent intent)를 이용해 액티비티에서 다른 액티비티를 실행시킴
- 이 과정은 액티비티를 직접 실행시키는 것이 아니라 안드로이드 OS(ActivityManager라고 하는 컴포넌트로)에 실행요청을 하는 것
- 매개변수 intent를 통해 어떤 액티비티를 시작시킬지 전달가능

- Intent
- Intent는 컴포넌트가 운영체제와 통신하기 위해 사용할 수 있는 객체를 의미. -> 다목적 통신도구
- 액티비티도 컴포넌트 중 하나이고, 컴포넌트의 종류는 많음 (서비스, 브로드캐스트 수신자, 콘텐트 제공자 등)
- Intent 클래스를 이용해 용도에 따라 여러 종류의 오버로딩된 생성자들을 제공함
- Public Intent(Context packageContext, Class<?> cos) 로 intent 생성
- Class 인자는 ActivityManager가 시작시켜야 하는 액티비티 클래스를 나타내고, 
- Context 인자는 그 액티비티 클래스를 찾을 수 있는 앱 패키지를 ActivityManager에게 알려줌
- 여기서는 한 애플리케이션 내에 두개의 액티비티가 외부의 ActivityManager를 통해 통신하는 것이므로 명시적(explicit) 인텐트라고 한다
- 두개의 애플리케이션 사이에서 액티비티를 실행시킬때에는 암시적(implicit) 인텐트라고함

- 액티비티 간 데이터 전달 (인텐트 엑스트라 사용하기)
- 엑스트라는 액티비티가 인텐트에 포함시킬 수 있는 임의의 데이터
- 키와 값이 한 쌍으로 된 구조로, 전에 Bundle에 저장했던 것과 동일
- Public Intent putExtra(String name, boolean value) 사용해서 엑스트라 추가
- 엑스트라 키는 엑스트라의 데이터를 읽어서 사용하고자 하는 액티비티 안에 정의해야함
- Activirt.getIntent() 메서드로 Intent 객체를 반환하고
- Public boolean getBooleanExtra(String name, boolean defaultValue) 를 이용해 엑스트라의 데이터 값을 읽음



* 3일차

- 자식 액티비티로부터 결과 돌려받기
- Public void startActivityForResult(Intent intent, int requestCode) 를 부모 액티비티에 추가
- 자식 액티비티에서 데이터를 부모로 돌려주기위해 setResult(int resultCode, Intent data)나 setResult(int resultCode)를 사용
- 자식 액티비티가 startActivityForResult 로 시작되었다면 결과 코드는 항상 부모 액티비티에 반환되고
- 이때 자식 액티비티에서 setResult가 호출되지 않은 상태에서 사용자가 Back버튼을 누르면 부모는 Activity.RESULT_CAMCELED를 결과 코드로 받게됨 (정수0)


(6) 안드로이드 SDK 버전과 호환성
- 현재 장치의 sdk 버전을 확인/비교하여 상위버전의 api 코드를 안전하게 추가한다
- 개발자 문서 자주 보기!!
